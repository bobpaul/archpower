From 6f5732e9f83f111fa835d3737afaa37ed86f6a76 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Tue, 2 Oct 2018 23:27:13 +0200
Subject: [PATCH 01/13] SkJSON: Fix tagged value implementation for big endian

2.26.2


2.26.2


From 6aca27c8b850dd1a0c9b09d3112b397080c3d5b8 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Wed, 6 Mar 2019 20:21:59 +0100
Subject: [PATCH 04/13] skcms: skip swap in read_big_u{16,32} on BE

---
 .../chromium/third_party/skia/third_party/skcms/skcms.cc  | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/src/3rdparty/chromium/third_party/skia/third_party/skcms/skcms.cc b/src/3rdparty/chromium/third_party/skia/third_party/skcms/skcms.cc
index d6eb32ff3..25307d26c 100644
--- a/src/3rdparty/chromium/third_party/skia/third_party/skcms/skcms.cc
+++ b/src/3rdparty/chromium/third_party/skia/third_party/skcms/skcms.cc
@@ -281,21 +281,29 @@ enum {
 static uint16_t read_big_u16(const uint8_t* ptr) {
     uint16_t be;
     memcpy(&be, ptr, sizeof(be));
+#if __BIG_ENDIAN__
+    return be;
+#else
 #if defined(_MSC_VER)
     return _byteswap_ushort(be);
 #else
     return __builtin_bswap16(be);
 #endif
+#endif
 }
 
 static uint32_t read_big_u32(const uint8_t* ptr) {
     uint32_t be;
     memcpy(&be, ptr, sizeof(be));
+#if __BIG_ENDIAN__
+    return be;
+#else
 #if defined(_MSC_VER)
     return _byteswap_ulong(be);
 #else
     return __builtin_bswap32(be);
 #endif
+#endif
 }
 
 static int32_t read_big_i32(const uint8_t* ptr) {
-- 
2.26.2


From 33a16876727c88a0fbfbae748c21813df6138e16 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Wed, 27 Mar 2019 21:29:20 +0100
Subject: [PATCH 05/13] skcms: Handle endianness in transform code

---
 .../third_party/skcms/src/Transform_inl.h     | 165 ++++++++++++++++++
 1 file changed, 165 insertions(+)

diff --git a/src/3rdparty/chromium/third_party/skia/third_party/skcms/src/Transform_inl.h b/src/3rdparty/chromium/third_party/skia/third_party/skcms/src/Transform_inl.h
index c4b312286..4927106e0 100644
--- a/src/3rdparty/chromium/third_party/skia/third_party/skcms/src/Transform_inl.h
+++ b/src/3rdparty/chromium/third_party/skia/third_party/skcms/src/Transform_inl.h
@@ -507,9 +507,11 @@ SI U32 gather_32(const uint8_t* p, I32 ix) {
 }
 
 SI U32 gather_24(const uint8_t* p, I32 ix) {
+#if !__BIG_ENDIAN__
     // First, back up a byte.  Any place we're gathering from has a safe junk byte to read
     // in front of it, either a previous table value, or some tag metadata.
     p -= 1;
+#endif
 
     // Load the i'th 24-bit value from p, and 1 extra byte.
     auto load_24_32 = [p](int i) {
@@ -550,8 +552,10 @@ SI U32 gather_24(const uint8_t* p, I32 ix) {
 
 #if !defined(__arm__)
     SI void gather_48(const uint8_t* p, I32 ix, U64* v) {
+#if !__BIG_ENDIAN__
         // As in gather_24(), with everything doubled.
         p -= 2;
+#endif
 
         // Load the i'th 48-bit value from p, and 2 extra bytes.
         auto load_48_64 = [p](int i) {
@@ -614,9 +618,13 @@ SI F F_from_U8(U8 v) {
 SI F F_from_U16_BE(U16 v) {
     // All 16-bit ICC values are big-endian, so we byte swap before converting to float.
     // MSVC catches the "loss" of data here in the portable path, so we also make sure to mask.
+#if !__BIG_ENDIAN__
     U16 lo = (v >> 8),
         hi = (v << 8) & 0xffff;
     return cast<F>(lo|hi) * (1/65535.0f);
+#else
+    return cast<F>(v) * (1/65535.0f);
+#endif
 }
 
 SI U16 U16_from_F(F v) {
@@ -659,9 +667,15 @@ SI F table(const skcms_Curve* curve, F v) {
 SI void sample_clut_8(const skcms_A2B* a2b, I32 ix, F* r, F* g, F* b) {
     U32 rgb = gather_24(a2b->grid_8, ix);
 
+#if __BIG_ENDIAN__
+    *r = cast<F>((rgb >> 16) & 0xff) * (1/255.0f);
+    *g = cast<F>((rgb >>  8) & 0xff) * (1/255.0f);
+    *b = cast<F>((rgb >>  0) & 0xff) * (1/255.0f);
+#else
     *r = cast<F>((rgb >>  0) & 0xff) * (1/255.0f);
     *g = cast<F>((rgb >>  8) & 0xff) * (1/255.0f);
     *b = cast<F>((rgb >> 16) & 0xff) * (1/255.0f);
+#endif
 }
 
 SI void sample_clut_16(const skcms_A2B* a2b, I32 ix, F* r, F* g, F* b) {
@@ -674,12 +688,18 @@ SI void sample_clut_16(const skcms_A2B* a2b, I32 ix, F* r, F* g, F* b) {
     // This strategy is much faster for 64-bit builds, and fine for 32-bit x86 too.
     U64 rgb;
     gather_48(a2b->grid_16, ix, &rgb);
+#if __BIG_ENDIAN__
+    *r = cast<F>((rgb >> 32) & 0xffff) * (1/65535.0f);
+    *g = cast<F>((rgb >> 16) & 0xffff) * (1/65535.0f);
+    *b = cast<F>((rgb >>  0) & 0xffff) * (1/65535.0f);
+#else
     rgb = swap_endian_16x4(rgb);
 
     *r = cast<F>((rgb >>  0) & 0xffff) * (1/65535.0f);
     *g = cast<F>((rgb >> 16) & 0xffff) * (1/65535.0f);
     *b = cast<F>((rgb >> 32) & 0xffff) * (1/65535.0f);
 #endif
+#endif
 }
 
 // GCC 7.2.0 hits an internal compiler error with -finline-functions (or -O3)
@@ -837,10 +857,17 @@ static void exec_ops(const Op* ops, const void** args,
             case Op_load_8888:{
                 U32 rgba = load<U32>(src + 4*i);
 
+#if __BIG_ENDIAN__
+                r = cast<F>((rgba >> 24) & 0xff) * (1/255.0f);
+                g = cast<F>((rgba >> 16) & 0xff) * (1/255.0f);
+                b = cast<F>((rgba >>  8) & 0xff) * (1/255.0f);
+                a = cast<F>((rgba >>  0) & 0xff) * (1/255.0f);
+#else
                 r = cast<F>((rgba >>  0) & 0xff) * (1/255.0f);
                 g = cast<F>((rgba >>  8) & 0xff) * (1/255.0f);
                 b = cast<F>((rgba >> 16) & 0xff) * (1/255.0f);
                 a = cast<F>((rgba >> 24) & 0xff) * (1/255.0f);
+#endif
             } break;
 
             case Op_load_8888_palette8:{
@@ -874,13 +901,29 @@ static void exec_ops(const Op* ops, const void** args,
                 b = cast<F>((U16)v.val[2]) * (1/65535.0f);
             #elif defined(USING_NEON)
                 uint16x4x3_t v = vld3_u16(rgb);
+#if __BIG_ENDIAN__
+                r = cast<F>(swap_endian_16((U16)v.val[0])) * (1/65535.0f);
+                g = cast<F>(swap_endian_16((U16)v.val[1])) * (1/65535.0f);
+                b = cast<F>(swap_endian_16((U16)v.val[2])) * (1/65535.0f);
+#else
                 r = cast<F>((U16)v.val[0]) * (1/65535.0f);
                 g = cast<F>((U16)v.val[1]) * (1/65535.0f);
                 b = cast<F>((U16)v.val[2]) * (1/65535.0f);
+#endif
             #else
+#if __BIG_ENDIAN__
+                U32 R = load_3<U32>(rgb+0),
+                    G = load_3<U32>(rgb+1),
+                    B = load_3<U32>(rgb+2);
+                // R,G,B are little-endian 16-bit, so byte swap them before converting to float.
+                r = cast<F>((R & 0x00ff)<<8 | (R & 0xff00)>>8) * (1/65535.0f);
+                g = cast<F>((G & 0x00ff)<<8 | (G & 0xff00)>>8) * (1/65535.0f);
+                b = cast<F>((B & 0x00ff)<<8 | (B & 0xff00)>>8) * (1/65535.0f);
+#else
                 r = cast<F>(load_3<U32>(rgb+0)) * (1/65535.0f);
                 g = cast<F>(load_3<U32>(rgb+1)) * (1/65535.0f);
                 b = cast<F>(load_3<U32>(rgb+2)) * (1/65535.0f);
+#endif
             #endif
             } break;
 
@@ -896,17 +939,33 @@ static void exec_ops(const Op* ops, const void** args,
                 a = cast<F>((U16)v.val[3]) * (1/65535.0f);
             #elif defined(USING_NEON)
                 uint16x4x4_t v = vld4_u16(rgba);
+#if __BIG_ENDIAN__
+                r = cast<F>(swap_endian_16((U16)v.val[0])) * (1/65535.0f);
+                g = cast<F>(swap_endian_16((U16)v.val[1])) * (1/65535.0f);
+                b = cast<F>(swap_endian_16((U16)v.val[2])) * (1/65535.0f);
+                a = cast<F>(swap_endian_16((U16)v.val[3])) * (1/65535.0f);
+#else
                 r = cast<F>((U16)v.val[0]) * (1/65535.0f);
                 g = cast<F>((U16)v.val[1]) * (1/65535.0f);
                 b = cast<F>((U16)v.val[2]) * (1/65535.0f);
                 a = cast<F>((U16)v.val[3]) * (1/65535.0f);
+#endif
             #else
+#if __BIG_ENDIAN__
+                U64 px = swap_endian_16x4(load<U64>(rgba));
+
+                r = cast<F>((px >> 48) & 0xffff) * (1/65535.0f);
+                g = cast<F>((px >> 32) & 0xffff) * (1/65535.0f);
+                b = cast<F>((px >> 16) & 0xffff) * (1/65535.0f);
+                a = cast<F>((px >>  0) & 0xffff) * (1/65535.0f);
+#else
                 U64 px = load<U64>(rgba);
 
                 r = cast<F>((px >>  0) & 0xffff) * (1/65535.0f);
                 g = cast<F>((px >> 16) & 0xffff) * (1/65535.0f);
                 b = cast<F>((px >> 32) & 0xffff) * (1/65535.0f);
                 a = cast<F>((px >> 48) & 0xffff) * (1/65535.0f);
+#endif
             #endif
             } break;
 
@@ -921,10 +980,21 @@ static void exec_ops(const Op* ops, const void** args,
                 b = cast<F>(swap_endian_16((U16)v.val[2])) * (1/65535.0f);
             #elif defined(USING_NEON)
                 uint16x4x3_t v = vld3_u16(rgb);
+#if __BIG_ENDIAN__
+                r = cast<F>((U16)v.val[0]) * (1/65535.0f);
+                g = cast<F>((U16)v.val[1]) * (1/65535.0f);
+                b = cast<F>((U16)v.val[2]) * (1/65535.0f);
+#else
                 r = cast<F>(swap_endian_16((U16)v.val[0])) * (1/65535.0f);
                 g = cast<F>(swap_endian_16((U16)v.val[1])) * (1/65535.0f);
                 b = cast<F>(swap_endian_16((U16)v.val[2])) * (1/65535.0f);
+#endif
             #else
+#if __BIG_ENDIAN__
+                r = cast<F>(load_3<U32>(rgb+0)) * (1/65535.0f);
+                g = cast<F>(load_3<U32>(rgb+1)) * (1/65535.0f);
+                b = cast<F>(load_3<U32>(rgb+2)) * (1/65535.0f);
+#else
                 U32 R = load_3<U32>(rgb+0),
                     G = load_3<U32>(rgb+1),
                     B = load_3<U32>(rgb+2);
@@ -932,6 +1002,7 @@ static void exec_ops(const Op* ops, const void** args,
                 r = cast<F>((R & 0x00ff)<<8 | (R & 0xff00)>>8) * (1/65535.0f);
                 g = cast<F>((G & 0x00ff)<<8 | (G & 0xff00)>>8) * (1/65535.0f);
                 b = cast<F>((B & 0x00ff)<<8 | (B & 0xff00)>>8) * (1/65535.0f);
+#endif
             #endif
             } break;
 
@@ -947,17 +1018,33 @@ static void exec_ops(const Op* ops, const void** args,
                 a = cast<F>(swap_endian_16((U16)v.val[3])) * (1/65535.0f);
             #elif defined(USING_NEON)
                 uint16x4x4_t v = vld4_u16(rgba);
+#if __BIG_ENDIAN__
+                r = cast<F>((U16)v.val[0]) * (1/65535.0f);
+                g = cast<F>((U16)v.val[1]) * (1/65535.0f);
+                b = cast<F>((U16)v.val[2]) * (1/65535.0f);
+                a = cast<F>((U16)v.val[3]) * (1/65535.0f);
+#else
                 r = cast<F>(swap_endian_16((U16)v.val[0])) * (1/65535.0f);
                 g = cast<F>(swap_endian_16((U16)v.val[1])) * (1/65535.0f);
                 b = cast<F>(swap_endian_16((U16)v.val[2])) * (1/65535.0f);
                 a = cast<F>(swap_endian_16((U16)v.val[3])) * (1/65535.0f);
+#endif
             #else
+#if __BIG_ENDIAN__
+                U64 px = load<U64>(rgba);
+
+                r = cast<F>((px >> 48) & 0xffff) * (1/65535.0f);
+                g = cast<F>((px >> 32) & 0xffff) * (1/65535.0f);
+                b = cast<F>((px >> 16) & 0xffff) * (1/65535.0f);
+                a = cast<F>((px >>  0) & 0xffff) * (1/65535.0f);
+#else
                 U64 px = swap_endian_16x4(load<U64>(rgba));
 
                 r = cast<F>((px >>  0) & 0xffff) * (1/65535.0f);
                 g = cast<F>((px >> 16) & 0xffff) * (1/65535.0f);
                 b = cast<F>((px >> 32) & 0xffff) * (1/65535.0f);
                 a = cast<F>((px >> 48) & 0xffff) * (1/65535.0f);
+#endif
             #endif
             } break;
 
@@ -1003,10 +1090,17 @@ static void exec_ops(const Op* ops, const void** args,
                     A = (U16)v.val[3];
             #else
                 U64 px = load<U64>(rgba);
+#if __BIG_ENDIAN__
+                U16 R = cast<U16>((px >> 48) & 0xffff),
+                    G = cast<U16>((px >> 32) & 0xffff),
+                    B = cast<U16>((px >> 16) & 0xffff),
+                    A = cast<U16>((px >>  0) & 0xffff);
+#else
                 U16 R = cast<U16>((px >>  0) & 0xffff),
                     G = cast<U16>((px >> 16) & 0xffff),
                     B = cast<U16>((px >> 32) & 0xffff),
                     A = cast<U16>((px >> 48) & 0xffff);
+#endif
             #endif
                 r = F_from_Half(R);
                 g = F_from_Half(G);
@@ -1243,10 +1337,17 @@ static void exec_ops(const Op* ops, const void** args,
             } return;
 
             case Op_store_8888: {
+#if __BIG_ENDIAN__
+                store(dst + 4*i, cast<U32>(to_fixed(r * 255)) << 24
+                               | cast<U32>(to_fixed(g * 255)) << 16
+                               | cast<U32>(to_fixed(b * 255)) <<  8
+                               | cast<U32>(to_fixed(a * 255)) <<  0);
+#else
                 store(dst + 4*i, cast<U32>(to_fixed(r * 255)) <<  0
                                | cast<U32>(to_fixed(g * 255)) <<  8
                                | cast<U32>(to_fixed(b * 255)) << 16
                                | cast<U32>(to_fixed(a * 255)) << 24);
+#endif
             } return;
 
             case Op_store_1010102: {
@@ -1269,15 +1370,30 @@ static void exec_ops(const Op* ops, const void** args,
                 vst3q_u16(rgb, v);
             #elif defined(USING_NEON)
                 uint16x4x3_t v = {{
+#if __BIG_ENDIAN__
+                    (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(r))),
+                    (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(g))),
+                    (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(b))),
+#else
                     (uint16x4_t)U16_from_F(r),
                     (uint16x4_t)U16_from_F(g),
                     (uint16x4_t)U16_from_F(b),
+#endif
                 }};
                 vst3_u16(rgb, v);
             #else
+#if __BIG_ENDIAN__
+                U32 R = to_fixed(r * 65535),
+                    G = to_fixed(g * 65535),
+                    B = to_fixed(b * 65535);
+                store_3(rgb+0, cast<U16>((R & 0x00ff) << 8 | (R & 0xff00) >> 8) );
+                store_3(rgb+1, cast<U16>((G & 0x00ff) << 8 | (G & 0xff00) >> 8) );
+                store_3(rgb+2, cast<U16>((B & 0x00ff) << 8 | (B & 0xff00) >> 8) );
+#else
                 store_3(rgb+0, U16_from_F(r));
                 store_3(rgb+1, U16_from_F(g));
                 store_3(rgb+2, U16_from_F(b));
+#endif
             #endif
 
             } return;
@@ -1296,18 +1412,33 @@ static void exec_ops(const Op* ops, const void** args,
                 vst4q_u16(rgba, v);
             #elif defined(USING_NEON)
                 uint16x4x4_t v = {{
+#if __BIG_ENDIAN__
+                    (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(r))),
+                    (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(g))),
+                    (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(b))),
+                    (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(a))),
+#else
                     (uint16x4_t)U16_from_F(r),
                     (uint16x4_t)U16_from_F(g),
                     (uint16x4_t)U16_from_F(b),
                     (uint16x4_t)U16_from_F(a),
+#endif
                 }};
                 vst4_u16(rgba, v);
             #else
+#if __BIG_ENDIAN__
+                U64 px = cast<U64>(to_fixed(r * 65535)) << 48
+                       | cast<U64>(to_fixed(g * 65535)) << 32
+                       | cast<U64>(to_fixed(b * 65535)) << 16
+                       | cast<U64>(to_fixed(a * 65535)) <<  0;
+                store(rgba, swap_endian_16x4(px));
+#else
                 U64 px = cast<U64>(to_fixed(r * 65535)) <<  0
                        | cast<U64>(to_fixed(g * 65535)) << 16
                        | cast<U64>(to_fixed(b * 65535)) << 32
                        | cast<U64>(to_fixed(a * 65535)) << 48;
                 store(rgba, px);
+#endif
             #endif
             } return;
 
@@ -1324,18 +1455,30 @@ static void exec_ops(const Op* ops, const void** args,
                 vst3q_u16(rgb, v);
             #elif defined(USING_NEON)
                 uint16x4x3_t v = {{
+#if __BIG_ENDIAN__
+                    (uint16x4_t)U16_from_F(r),
+                    (uint16x4_t)U16_from_F(g),
+                    (uint16x4_t)U16_from_F(b),
+#else
                     (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(r))),
                     (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(g))),
                     (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(b))),
+#endif
                 }};
                 vst3_u16(rgb, v);
             #else
+#if __BIG_ENDIAN__
+                store_3(rgb+0, U16_from_F(r));
+                store_3(rgb+1, U16_from_F(g));
+                store_3(rgb+2, U16_from_F(b));
+#else
                 U32 R = to_fixed(r * 65535),
                     G = to_fixed(g * 65535),
                     B = to_fixed(b * 65535);
                 store_3(rgb+0, cast<U16>((R & 0x00ff) << 8 | (R & 0xff00) >> 8) );
                 store_3(rgb+1, cast<U16>((G & 0x00ff) << 8 | (G & 0xff00) >> 8) );
                 store_3(rgb+2, cast<U16>((B & 0x00ff) << 8 | (B & 0xff00) >> 8) );
+#endif
             #endif
 
             } return;
@@ -1354,18 +1497,33 @@ static void exec_ops(const Op* ops, const void** args,
                 vst4q_u16(rgba, v);
             #elif defined(USING_NEON)
                 uint16x4x4_t v = {{
+#if __BIG_ENDIAN__
+                    (uint16x4_t)U16_from_F(r),
+                    (uint16x4_t)U16_from_F(g),
+                    (uint16x4_t)U16_from_F(b),
+                    (uint16x4_t)U16_from_F(a),
+#else
                     (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(r))),
                     (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(g))),
                     (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(b))),
                     (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(a))),
+#endif
                 }};
                 vst4_u16(rgba, v);
             #else
+#if __BIG_ENDIAN__
+                U64 px = cast<U64>(to_fixed(r * 65535)) << 48
+                       | cast<U64>(to_fixed(g * 65535)) << 32
+                       | cast<U64>(to_fixed(b * 65535)) << 16
+                       | cast<U64>(to_fixed(a * 65535)) <<  0;
+                store(rgba, px);
+#else
                 U64 px = cast<U64>(to_fixed(r * 65535)) <<  0
                        | cast<U64>(to_fixed(g * 65535)) << 16
                        | cast<U64>(to_fixed(b * 65535)) << 32
                        | cast<U64>(to_fixed(a * 65535)) << 48;
                 store(rgba, swap_endian_16x4(px));
+#endif
             #endif
             } return;
 
@@ -1424,10 +1582,17 @@ static void exec_ops(const Op* ops, const void** args,
                 }};
                 vst4_u16(rgba, v);
             #else
+#if __BIG_ENDIAN__
+                store(rgba, cast<U64>(R) << 48
+                          | cast<U64>(G) << 32
+                          | cast<U64>(B) << 16
+                          | cast<U64>(A) <<  0);
+#else
                 store(rgba, cast<U64>(R) <<  0
                           | cast<U64>(G) << 16
                           | cast<U64>(B) << 32
                           | cast<U64>(A) << 48);
+#endif
             #endif
 
             } return;
-- 
2.26.2


From 41a7bcc1ae40af489eef518ed6a884d79af57756 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sat, 6 Apr 2019 23:32:18 +0200
Subject: [PATCH 06/13] SkRasterPipeline_opts: Handle endianness in 32-bit
 pixel load/store

---
 .../skia/src/opts/SkRasterPipeline_opts.h     | 40 +++++++++++++++++++
 1 file changed, 40 insertions(+)

diff --git a/src/3rdparty/chromium/third_party/skia/src/opts/SkRasterPipeline_opts.h b/src/3rdparty/chromium/third_party/skia/src/opts/SkRasterPipeline_opts.h
index 0d610ccfe..3607c936b 100644
--- a/src/3rdparty/chromium/third_party/skia/src/opts/SkRasterPipeline_opts.h
+++ b/src/3rdparty/chromium/third_party/skia/src/opts/SkRasterPipeline_opts.h
@@ -1210,10 +1210,17 @@ SI void from_4444(U16 _4444, F* r, F* g, F* b, F* a) {
     *a = cast(wide & (15<< 0)) * (1.0f / (15<< 0));
 }
 SI void from_8888(U32 _8888, F* r, F* g, F* b, F* a) {
+#ifdef SK_CPU_BENDIAN
+    *r = cast((_8888 >> 24)       ) * (1/255.0f);
+    *g = cast((_8888 >> 16) & 0xff) * (1/255.0f);
+    *b = cast((_8888 >>  8) & 0xff) * (1/255.0f);
+    *a = cast((_8888      ) & 0xff) * (1/255.0f);
+#else
     *r = cast((_8888      ) & 0xff) * (1/255.0f);
     *g = cast((_8888 >>  8) & 0xff) * (1/255.0f);
     *b = cast((_8888 >> 16) & 0xff) * (1/255.0f);
     *a = cast((_8888 >> 24)       ) * (1/255.0f);
+#endif
 }
 SI void from_88(U16 _88, F* r, F* g) {
     U32 wide = expand(_88);
@@ -1575,10 +1582,17 @@ STAGE(srcover_rgba_8888, const SkRasterPipeline_MemoryCtx* ctx) {
     auto ptr = ptr_at_xy<uint32_t>(ctx, dx,dy);
 
     U32 dst = load<U32>(ptr, tail);
+#ifdef SK_CPU_BENDIAN
+    dr = cast((dst >> 24)       );
+    dg = cast((dst >> 16) & 0xff);
+    db = cast((dst >>  8) & 0xff);
+    da = cast((dst      ) & 0xff);
+#else
     dr = cast((dst      ) & 0xff);
     dg = cast((dst >>  8) & 0xff);
     db = cast((dst >> 16) & 0xff);
     da = cast((dst >> 24)       );
+#endif
     // {dr,dg,db,da} are in [0,255]
     // { r, g, b, a} are in [0,  1] (but may be out of gamut)
 
@@ -1589,10 +1603,17 @@ STAGE(srcover_rgba_8888, const SkRasterPipeline_MemoryCtx* ctx) {
     // { r, g, b, a} are now in [0,255]  (but may be out of gamut)
 
     // to_unorm() clamps back to gamut.  Scaling by 1 since we're already 255-biased.
+#ifdef SK_CPU_BENDIAN
+    dst = to_unorm(r, 1, 255) << 24
+        | to_unorm(g, 1, 255) << 16
+        | to_unorm(b, 1, 255) <<  8
+        | to_unorm(a, 1, 255);
+#else
     dst = to_unorm(r, 1, 255)
         | to_unorm(g, 1, 255) <<  8
         | to_unorm(b, 1, 255) << 16
         | to_unorm(a, 1, 255) << 24;
+#endif
     store(ptr, dst, tail);
 }
 
@@ -2042,10 +2063,17 @@ STAGE(gather_8888, const SkRasterPipeline_GatherCtx* ctx) {
 STAGE(store_8888, const SkRasterPipeline_MemoryCtx* ctx) {
     auto ptr = ptr_at_xy<uint32_t>(ctx, dx,dy);
 
+#ifdef SK_CPU_BENDIAN
+    U32 px = to_unorm(r, 255) << 24
+           | to_unorm(g, 255) << 16
+           | to_unorm(b, 255) <<  8
+           | to_unorm(a, 255);
+#else
     U32 px = to_unorm(r, 255)
            | to_unorm(g, 255) <<  8
            | to_unorm(b, 255) << 16
            | to_unorm(a, 255) << 24;
+#endif
     store(ptr, px, tail);
 }
 
@@ -3542,10 +3570,17 @@ SI void from_8888(U32 rgba, U16* r, U16* g, U16* b, U16* a) {
         return cast<U16>(v);
     };
 #endif
+#ifdef SK_CPU_BENDIAN
+    *r = cast_U16(rgba >>   16) >>  8;
+    *g = cast_U16(rgba >>   16) & 255;
+    *b = cast_U16(rgba & 65535) >>  8;
+    *a = cast_U16(rgba & 65535) & 255;
+#else
     *r = cast_U16(rgba & 65535) & 255;
     *g = cast_U16(rgba & 65535) >>  8;
     *b = cast_U16(rgba >>   16) & 255;
     *a = cast_U16(rgba >>   16) >>  8;
+#endif
 }
 
 SI void load_8888_(const uint32_t* ptr, size_t tail, U16* r, U16* g, U16* b, U16* a) {
@@ -3587,10 +3622,15 @@ SI void store_8888_(uint32_t* ptr, size_t tail, U16 r, U16 g, U16 b, U16 a) {
         case 2: vst4_lane_u8((uint8_t*)(ptr+1), rgba, 1);
         case 1: vst4_lane_u8((uint8_t*)(ptr+0), rgba, 0);
     }
+#else
+#ifdef SK_CPU_BENDIAN
+    store(ptr, tail, cast<U32>((r<<8) | g) << 16
+                   | cast<U32>((b<<8) | a) << 0);
 #else
     store(ptr, tail, cast<U32>(r | (g<<8)) <<  0
                    | cast<U32>(b | (a<<8)) << 16);
 #endif
+#endif
 }
 
 STAGE_PP(load_8888, const SkRasterPipeline_MemoryCtx* ctx) {
-- 
2.26.2


From b0423bb99eaf7f28f1e20aa7de3c72d605d3e394 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sun, 7 Apr 2019 12:00:05 +0200
Subject: [PATCH 07/13] SkPixmap: Fix getColor on pixmaps with non-premul alpha

The trick to use SkSwizzle_BGRA_to_PMColor() to get an SkColor from an
SkPMColor only works on LE, because an SkColor is actually fixed as
ARGB in register order, so on BE it becomes ARGB is memory order, not BGRA.
---
 src/3rdparty/chromium/third_party/skia/src/core/SkPixmap.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/3rdparty/chromium/third_party/skia/src/core/SkPixmap.cpp b/src/3rdparty/chromium/third_party/skia/src/core/SkPixmap.cpp
index c8a09ff7c..2089784a3 100644
--- a/src/3rdparty/chromium/third_party/skia/src/core/SkPixmap.cpp
+++ b/src/3rdparty/chromium/third_party/skia/src/core/SkPixmap.cpp
@@ -266,7 +266,8 @@ SkColor SkPixmap::getColor(int x, int y) const {
     const bool needsUnpremul = (kPremul_SkAlphaType == fInfo.alphaType());
     auto toColor = [needsUnpremul](uint32_t maybePremulColor) {
         return needsUnpremul ? SkUnPreMultiply::PMColorToColor(maybePremulColor)
-                             : SkSwizzle_BGRA_to_PMColor(maybePremulColor);
+                             : SkColorSetARGB(SkGetPackedA32(maybePremulColor), SkGetPackedR32(maybePremulColor),
+					      SkGetPackedG32(maybePremulColor), SkGetPackedB32(maybePremulColor));
     };
 
     switch (this->colorType()) {
-- 
2.26.2


From a2e09e509a9bb9f2e712c3684246b70de273b7ef Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sun, 7 Apr 2019 21:12:17 +0200
Subject: [PATCH 08/13] skcms: skip swap in eval_curve on BE

---
 .../chromium/third_party/skia/third_party/skcms/skcms.cc     | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/3rdparty/chromium/third_party/skia/third_party/skcms/skcms.cc b/src/3rdparty/chromium/third_party/skia/third_party/skcms/skcms.cc
index 25307d26c..fd436c428 100644
--- a/src/3rdparty/chromium/third_party/skia/third_party/skcms/skcms.cc
+++ b/src/3rdparty/chromium/third_party/skia/third_party/skcms/skcms.cc
@@ -222,10 +222,15 @@ static float eval_curve(const skcms_Curve* curve, float x) {
         uint16_t be_l, be_h;
         memcpy(&be_l, curve->table_16 + 2*lo, 2);
         memcpy(&be_h, curve->table_16 + 2*hi, 2);
+#if __BIG_ENDIAN__
+        l = be_l * (1/65535.0f);
+        h = be_h * (1/65535.0f);
+#else
         uint16_t le_l = ((be_l << 8) | (be_l >> 8)) & 0xffff;
         uint16_t le_h = ((be_h << 8) | (be_h >> 8)) & 0xffff;
         l = le_l * (1/65535.0f);
         h = le_h * (1/65535.0f);
+#endif
     }
     return l + (h-l)*t;
 }
-- 
2.26.2


From b132016a958c48536b8493c4c13ab2a409320e37 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sat, 18 May 2019 11:20:48 +0200
Subject: [PATCH 09/13] SkColor: Fix conversion between SkColor4f and SkColor

SkColor4f is a vector of 4 floats with the fixed component order
<R, G, B, A>.  SkColor on the other hand is defined as a single
32-bit number with the value 0xAARRGGBB.  When converting this
to/from a vector using Sk4f_fromL32 and Sk4f_toL32, the vector
becomes <A, R, G, B> on BE and <B, G, R, A> on LE.  Thus different
swizzles are needed to get to/from the order <R, G, B, A>.

Fix courtesy of awilfox.
---
 .../third_party/skia/src/core/SkColor.cpp     | 20 +++++++++++++++++--
 1 file changed, 18 insertions(+), 2 deletions(-)

diff --git a/src/3rdparty/chromium/third_party/skia/src/core/SkColor.cpp b/src/3rdparty/chromium/third_party/skia/src/core/SkColor.cpp
index efcc4b9c4..38f619bdb 100644
--- a/src/3rdparty/chromium/third_party/skia/src/core/SkColor.cpp
+++ b/src/3rdparty/chromium/third_party/skia/src/core/SkColor.cpp
@@ -108,13 +108,29 @@ SkColor SkHSVToColor(U8CPU a, const SkScalar hsv[3]) {
 template <>
 SkColor4f SkColor4f::FromColor(SkColor bgra) {
     SkColor4f rgba;
-    swizzle_rb(Sk4f_fromL32(bgra)).store(rgba.vec());
+    Sk4f c4f = Sk4f_fromL32(bgra);
+#ifdef SK_CPU_BENDIAN
+    // ARGB -> RGBA
+    c4f = SkNx_shuffle<1, 2, 3, 0>(c4f);
+#else
+    // BGRA -> RGBA
+    c4f = swizzle_rb(c4f);
+#endif
+    c4f.store(rgba.vec());
     return rgba;
 }
 
 template <>
 SkColor SkColor4f::toSkColor() const {
-    return Sk4f_toL32(swizzle_rb(Sk4f::Load(this->vec())));
+    Sk4f c4f = Sk4f::Load(this->vec());
+#ifdef SK_CPU_BENDIAN
+    // RGBA -> ARGB
+    c4f = SkNx_shuffle<3, 0, 1, 2>(c4f);
+#else
+    // RGBA -> BGRA
+    c4f = swizzle_rb(c4f);
+#endif
+    return Sk4f_toL32(c4f);
 }
 
 template <>
-- 
2.26.2


From 1b7f325f7b6c72d54a34266805f6ea6cc76aff70 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sat, 18 May 2019 11:32:47 +0200
Subject: [PATCH 10/13] Remove some endianness asserts

diff --git a/src/3rdparty/chromium/third_party/skia/src/opts/Sk4px_none.h b/src/3rdparty/chromium/third_party/skia/src/opts/Sk4px_none.h
index 41e8168bb..8de68419d 100644
--- a/src/3rdparty/chromium/third_party/skia/src/opts/Sk4px_none.h
+++ b/src/3rdparty/chromium/third_party/skia/src/opts/Sk4px_none.h
@@ -35,7 +35,6 @@ inline Sk4px Sk4px::Wide::div255() const {
 }
 
 inline Sk4px Sk4px::alphas() const {
-    static_assert(SK_A32_SHIFT == 24, "This method assumes little-endian.");
     return Sk16b((*this)[ 3], (*this)[ 3], (*this)[ 3], (*this)[ 3],
                  (*this)[ 7], (*this)[ 7], (*this)[ 7], (*this)[ 7],
                  (*this)[11], (*this)[11], (*this)[11], (*this)[11],
-- 
2.26.2


From 668cd6875fba861f90cc6409f029cae1c88a3035 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Wed, 6 Jan 2021 13:40:58 +0100
Subject: [PATCH 11/13] Fix RGBA and BGRA shifts on big endian

---
 .../third_party/skia/include/core/SkColorPriv.h  | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/src/3rdparty/chromium/third_party/skia/include/core/SkColorPriv.h b/src/3rdparty/chromium/third_party/skia/include/core/SkColorPriv.h
index 7078d92ac..6cd0573f6 100644
--- a/src/3rdparty/chromium/third_party/skia/include/core/SkColorPriv.h
+++ b/src/3rdparty/chromium/third_party/skia/include/core/SkColorPriv.h
@@ -56,6 +56,20 @@ static inline U8CPU SkUnitScalarClampToByte(SkScalar x) {
  *  Here we enforce this constraint.
  */
 
+#if defined(SK_CPU_BENDIAN)
+
+#define SK_RGBA_R32_SHIFT   24
+#define SK_RGBA_G32_SHIFT   16
+#define SK_RGBA_B32_SHIFT   8
+#define SK_RGBA_A32_SHIFT   0
+
+#define SK_BGRA_B32_SHIFT   24
+#define SK_BGRA_G32_SHIFT   16
+#define SK_BGRA_R32_SHIFT   8
+#define SK_BGRA_A32_SHIFT   0
+
+#else
+
 #define SK_RGBA_R32_SHIFT   0
 #define SK_RGBA_G32_SHIFT   8
 #define SK_RGBA_B32_SHIFT   16
@@ -66,6 +80,8 @@ static inline U8CPU SkUnitScalarClampToByte(SkScalar x) {
 #define SK_BGRA_R32_SHIFT   16
 #define SK_BGRA_A32_SHIFT   24
 
+#endif
+
 #if defined(SK_PMCOLOR_IS_RGBA) || defined(SK_PMCOLOR_IS_BGRA)
     #error "Configure PMCOLOR by setting SK_R32_SHIFT."
 #endif
-- 
2.26.2


From a3edb9ab47f2a0f842fcaf8c103be151126cc677 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Wed, 6 Jan 2021 13:42:39 +0100
Subject: [PATCH 12/13] Avoid redefining SK_G32_SHIFT and SK_A32_SHIFT

---
 .../third_party/skia/include/private/SkNx.h        | 14 ++++++++++----
 1 file changed, 10 insertions(+), 4 deletions(-)

diff --git a/src/3rdparty/chromium/third_party/skia/include/private/SkNx.h b/src/3rdparty/chromium/third_party/skia/include/private/SkNx.h
index 240f4f4db..6cf29a257 100644
--- a/src/3rdparty/chromium/third_party/skia/include/private/SkNx.h
+++ b/src/3rdparty/chromium/third_party/skia/include/private/SkNx.h
@@ -286,13 +286,19 @@ private:
 
     template <typename Bits>
     AI static T FromBits(Bits bits) {
-        static_assert(std::is_pod<T   >::value &&
-                      std::is_pod<Bits>::value &&
-                      sizeof(T) <= sizeof(Bits), "");
         T val;
-        memcpy(&val, &bits, sizeof(T));
+        FromBits(val, bits);
         return val;
     }
+    template <typename U, typename Bits>
+    AI static void FromBits(U& v, Bits bits) {
+        static_assert(std::is_integral<U   >::value &&
+                      std::is_integral<Bits>::value);
+        v = bits;
+    }
+    AI static void FromBits(float& v, int32_t bits)  { memcpy(&v, &bits, sizeof(v)); }
+    AI static void FromBits(double& v, int64_t bits) { memcpy(&v, &bits, sizeof(v)); }
+
 };
 
 // Allow scalars on the left or right of binary operators, and things like +=, &=, etc.
-- 
2.26.2

